/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.5 scene.gltf
Author: l0wpoly (https://sketchfab.com/l0wpoly)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/robot-80a736ddac1044299b134cfcca87c7f9
Title: Robot
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'

export function Robot(props) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('./Assets/robot/scene.gltf')
  const { actions, names } = useAnimations(animations, group)
  const [currentIndex, setCurrentIndex] = useState(0) // Index of the current direction
  const animationDuration = 1 // Duration of each animation step in seconds
  const stepDistance = 0.01 // Distance to move in each animation step
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
    z: 0
  })

  useFrame(() => {
    const mesh = group.current
    let direction
    // Calculate the current direction
    if (currentIndex <= props.directions.length - 1) {
      direction = props.directions[currentIndex]
      if (direction === 'left') {
        mesh.position.x -= stepDistance
        if (mesh.position.x < position.x - 1) {
          setCurrentIndex((prevIndex) => prevIndex + 1)
          setPosition({ ...position, x: position.x - 1 })
        }
        console.log(mesh.position.x)
        console.log(mesh.position.z)
      } else if (direction === 'up') {
        mesh.position.z -= stepDistance
        console.log(mesh.position.x)
        console.log(mesh.position.z)
        if (mesh.position.z < position.z - 1) {
          setCurrentIndex((prevIndex) => prevIndex + 1)
          setPosition({ ...position, z: position.z - 1 })
        }
        console.log(mesh.position.z)
      } else if (direction === 'right') {
        if (mesh.position.x > position.x + 1) {
          setCurrentIndex((prevIndex) => prevIndex + 1)
          setPosition({ ...position, x: position.x + 1 })
        }
        console.log(mesh.position.x)
        console.log(mesh.position.z)
        mesh.position.x += stepDistance
      } else if (direction === 'down') {
        mesh.position.z += stepDistance
        console.log(mesh.position.x)
        console.log(mesh.position.z)
        if (mesh.position.z > position.z + 1) {
          setCurrentIndex((prevIndex) => prevIndex + 1)
          setPosition({ ...position, z: position.z + 1 })
        }
      }
    }

    // Update the object's position based on the current direction
    console.log(position)
    console.log(direction)
    console.log(currentIndex)
  })

  return (
    <group ref={group} {...props} position={[0, 0.27, 0]} dispose={null}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 2*(Math.PI / 2)]}>
          <group name="robotfbx" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <group name="Object_2">
              <group name="RootNode">
                <group name="Object_4">
                  <primitive object={nodes._rootJoint} />
                  <group name="Object_6" rotation={[-Math.PI / 2, 0, 0]} />
                  <group name="hero" rotation={[-Math.PI / 2, 0, 0]} />
                  <skinnedMesh
                    name="Object_7"
                    geometry={nodes.Object_7.geometry}
                    material={materials.hero_texture}
                    skeleton={nodes.Object_7.skeleton}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('./Assets/robot/scene.gltf')
